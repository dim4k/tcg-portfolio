/* ============================================
   CARD DECK APPLICATION
   Interactive Pokemon-style card deck with 
   holographic effects and animations
   ============================================ */

/* ============================================
   CONFIGURATION & STATE
   ============================================ */
const CONFIG = {
    // Personal dates
    BIRTH_DATE: '1988-05-01',
    CAREER_START_DATE: '2011-05-01',
    
    // Images
    IMAGES: {
        card1: 'public/img/ak.jpg',
        card2: 'public/img/tech-stack.jpg',
        card3: 'public/img/elephant.jpg'
    },
    
    // Social links
    SOCIAL_LINKS: {
        linkedin: 'https://www.linkedin.com/in/antoine-kim/',
        email: 'contact@antoine.kim',
        github: 'https://github.com/dim4k',
        twitter: 'https://x.com/AntoineKim_',
        instagram: 'https://www.instagram.com/mikotna/'
    },
    
    // Animation settings
    MOBILE_BREAKPOINT: 600,
    SWIPE_THRESHOLD: 20,
    ANIMATION_DELAY: 300,
    ANIMATION_BUFFER: 100,
    HINT_INITIAL_DELAY: 5000,
    HINT_REPEAT_INTERVAL: 5000,
    HINT_DURATION: 3000,
    
    // 3D effect settings
    GYRO_SENSITIVITY: 0.5,
    GYRO_MAX_ROTATION: 15,
    MOUSE_ROTATION_FACTOR: 10,
    
    // Theme colors
    THEME_COLORS: {
        dark: '#0a0a0a',
        fire: '#4a0000',
        electric: '#5e4b00',
        psychic: '#2a004a',
        grass: '#0d3d1f',
        ice: '#0a3d52',
        default: '#101010'
    }
};

// Global state
const state = {
    isAnimating: false,
    isMobile: window.matchMedia(`(max-width: ${CONFIG.MOBILE_BREAKPOINT}px)`).matches,
    gyroBase: { beta: 0, gamma: 0 },
    gyroInitialized: false,
    swipeHintShown: false,
    swirlBackground: null
};

// DOM elements
const elements = {
    deckContainer: document.getElementById('deck'),
    cards: Array.from(document.querySelectorAll('.card')),
    body: document.body,
    swipeHint: document.querySelector('.swipe-hint-mobile')
};

/* ============================================
   UTILITY FUNCTIONS
   ============================================ */

/**
 * Calculate years since a given date
 * @param {string} dateString - Date in YYYY-MM-DD format
 * @returns {number} Number of full years
 */
function calculateYearsSince(dateString) {
    const startDate = new Date(dateString);
    const today = new Date();
    let years = today.getFullYear() - startDate.getFullYear();
    const monthDiff = today.getMonth() - startDate.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < startDate.getDate())) {
        years--;
    }
    return years;
}

/**
 * Update dynamic fields (age and experience)
 */
function updateDynamicFields() {
    const age = calculateYearsSince(CONFIG.BIRTH_DATE);
    const exp = calculateYearsSince(CONFIG.CAREER_START_DATE);

    const ageElement = document.getElementById('dynamic-age');
    const expElement = document.getElementById('dynamic-exp');
    
    if (ageElement) ageElement.textContent = age;
    if (expElement) expElement.textContent = exp;
}

/**
 * Update images from config
 */
function updateImages() {
    const images = document.querySelectorAll('.card-image');
    if (images[0]) images[0].src = CONFIG.IMAGES.card1;
    if (images[1]) images[1].src = CONFIG.IMAGES.card2;
    if (images[2]) images[2].src = CONFIG.IMAGES.card3;
}

/**
 * Update social links from config
 */
function updateSocialLinks() {
    // LinkedIn links (card 1 and 2)
    const linkedinLinks = document.querySelectorAll('a.linkedin');
    linkedinLinks.forEach(link => {
        link.href = CONFIG.SOCIAL_LINKS.linkedin;
    });
    
    // Email link (card 1)
    const emailLink = document.querySelector('a.email');
    if (emailLink) {
        emailLink.href = `mailto:${CONFIG.SOCIAL_LINKS.email}`;
    }
    
    // GitHub link (card 2)
    const githubLink = document.querySelector('a.github');
    if (githubLink) {
        githubLink.href = CONFIG.SOCIAL_LINKS.github;
    }
    
    // Twitter link (card 3)
    const twitterLink = document.querySelector('a.twitter');
    if (twitterLink) {
        twitterLink.href = CONFIG.SOCIAL_LINKS.twitter;
    }
    
    // Instagram link (card 3)
    const instagramLink = document.querySelector('a.instagram');
    if (instagramLink) {
        instagramLink.href = CONFIG.SOCIAL_LINKS.instagram;
    }
}

/**
 * Clamp a value between min and max
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * Get active card element
 * @returns {HTMLElement|null}
 */
function getActiveCard() {
    return document.querySelector('.card[data-pos="0"]');
}

/* ============================================
   CARD DECK MANAGEMENT
   ============================================ */

/**
 * Update card positions and background theme
 */
function updatePositions() {
    elements.cards.forEach((card, index) => {
        card.dataset.pos = index;
        card.classList.remove('slide-out', 're-enter');
        card.style.transform = ''; 
    });

    // Update background based on active card theme
    const activeCard = elements.cards[0];
    let themeColor = CONFIG.THEME_COLORS.default;
    let themeName = 'default';
    
    if (activeCard.classList.contains('theme-dark')) {
        themeColor = CONFIG.THEME_COLORS.dark;
        themeName = 'dark';
    } else if (activeCard.classList.contains('theme-fire')) {
        themeColor = CONFIG.THEME_COLORS.fire;
        themeName = 'fire';
    } else if (activeCard.classList.contains('theme-electric')) {
        themeColor = CONFIG.THEME_COLORS.electric;
        themeName = 'electric';
    } else if (activeCard.classList.contains('theme-psychic')) {
        themeColor = CONFIG.THEME_COLORS.psychic;
        themeName = 'psychic';
    } else if (activeCard.classList.contains('theme-grass')) {
        themeColor = CONFIG.THEME_COLORS.grass;
        themeName = 'grass';
    } else if (activeCard.classList.contains('theme-ice')) {
        themeColor = CONFIG.THEME_COLORS.ice;
        themeName = 'ice';
    }
    
    elements.body.style.backgroundColor = themeColor;
    
    // Update Swirl background theme (desktop only)
    if (state.swirlBackground && !state.isMobile) {
        state.swirlBackground.setTheme(themeName);
    }
}

/**
 * Rotate cards (move top card to bottom)
 */
function rotateCards() {
    if (state.isAnimating) return;
    state.isAnimating = true;

    const topCard = elements.cards[0];
    topCard.classList.add('slide-out');

    setTimeout(() => {
        elements.cards.push(elements.cards.shift());
        topCard.classList.remove('slide-out');
        updatePositions();
        
        setTimeout(() => {
            state.isAnimating = false;
        }, CONFIG.ANIMATION_BUFFER);
    }, CONFIG.ANIMATION_DELAY);
}

/* ============================================
   MOUSE INTERACTION
   ============================================ */

/**
 * Handle mouse movement over deck for 3D tilt effect
 */
function handleMouseMove(e) {
    const activeCard = getActiveCard();
    if (!activeCard || state.isAnimating) return;

    const rect = activeCard.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const centerX = rect.width / 2;
    const centerY = rect.height / 2;

    // Calculate rotation based on mouse position
    const rotateX = ((y - centerY) / centerY) * CONFIG.MOUSE_ROTATION_FACTOR;
    const rotateY = ((x - centerX) / centerX) * -CONFIG.MOUSE_ROTATION_FACTOR;

    activeCard.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.02)`;

    // Update holographic effects
    const glare = activeCard.querySelector('.glare');
    const holo = activeCard.querySelector('.holo-overlay');
    
    const pctX = (x / rect.width) * 100;
    const pctY = (y / rect.height) * 100;

    activeCard.style.setProperty('--mx', `${pctX}%`);
    activeCard.style.setProperty('--my', `${pctY}%`);
    
    if (glare) glare.style.opacity = '1';
    if (holo) holo.style.backgroundPosition = `${pctX}% ${pctY}%`;
}

/**
 * Reset card tilt when mouse leaves
 */
function handleMouseLeave() {
    const activeCard = getActiveCard();
    if (!activeCard) return;
    
    activeCard.style.transform = '';
    const glare = activeCard.querySelector('.glare');
    if (glare) glare.style.opacity = '0';
}

/* ============================================
   SCROLL & TOUCH INTERACTION
   ============================================ */

/**
 * Handle wheel scroll to rotate cards
 */
function handleWheel(e) {
    if (e.deltaY > 0) {
        rotateCards();
    }
}

/**
 * Handle touch swipe to rotate cards
 */
let touchStartY = 0;

function handleTouchStart(e) {
    touchStartY = e.touches[0].clientY;
}

function handleTouchEnd(e) {
    const touchEndY = e.changedTouches[0].clientY;
    const swipeDistance = touchEndY - touchStartY;
    
    if (swipeDistance > CONFIG.SWIPE_THRESHOLD) {
        rotateCards();
    }
}

/* ============================================
   GYROSCOPE (MOBILE)
   ============================================ */

/**
 * Handle device orientation for 3D tilt effect on mobile
 */
function handleOrientation(event) {
    const activeCard = getActiveCard();
    if (!activeCard || state.isAnimating) return;

    // Initialize base orientation on first movement
    if (!state.gyroInitialized) {
        state.gyroBase.beta = event.beta || 0;
        state.gyroBase.gamma = event.gamma || 0;
        state.gyroInitialized = true;
        return;
    }

    // Calculate relative rotation from base position
    const beta = event.beta || 0;   // Front-to-back tilt (-180 to 180)
    const gamma = event.gamma || 0; // Left-to-right tilt (-90 to 90)

    const relativeBeta = beta - state.gyroBase.beta;
    const relativeGamma = gamma - state.gyroBase.gamma;

    // Map gyro values to rotation with limits
    const rotateX = clamp(
        relativeBeta * CONFIG.GYRO_SENSITIVITY,
        -CONFIG.GYRO_MAX_ROTATION,
        CONFIG.GYRO_MAX_ROTATION
    );
    const rotateY = clamp(
        relativeGamma * CONFIG.GYRO_SENSITIVITY,
        -CONFIG.GYRO_MAX_ROTATION,
        CONFIG.GYRO_MAX_ROTATION
    );

    activeCard.style.transform = `perspective(1000px) rotateX(${-rotateX}deg) rotateY(${rotateY}deg)`;

    // Update holographic effects
    const glare = activeCard.querySelector('.glare');
    const holo = activeCard.querySelector('.holo-overlay');
    
    // Map gyro to percentage (center at 50%)
    const pctX = 50 + (relativeGamma * 2);
    const pctY = 50 + (relativeBeta * 2);

    activeCard.style.setProperty('--mx', `${pctX}%`);
    activeCard.style.setProperty('--my', `${pctY}%`);
    
    if (glare) glare.style.opacity = '0.8';
    if (holo) holo.style.backgroundPosition = `${pctX}% ${pctY}%`;
}

/**
 * Request permission for device orientation (iOS 13+)
 */
function requestGyroPermission() {
    if (typeof DeviceOrientationEvent !== 'undefined' && 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
            .then(response => {
                if (response === 'granted') {
                    window.addEventListener('deviceorientation', handleOrientation);
                }
            })
            .catch(console.error);
    } else {
        // Non-iOS or older iOS
        window.addEventListener('deviceorientation', handleOrientation);
    }
}

/**
 * Initialize gyroscope for mobile devices
 */
function initializeGyroscope() {
    if (!state.isMobile) return;

    if (typeof DeviceOrientationEvent !== 'undefined' && 
        typeof DeviceOrientationEvent.requestPermission !== 'function') {
        // Android or older iOS - enable immediately
        window.addEventListener('deviceorientation', handleOrientation);
    } else {
        // iOS 13+ - request permission on first touch
        document.addEventListener('touchstart', requestGyroPermission, { once: true });
    }
}

/* ============================================
   SWIPE HINT (MOBILE)
   ============================================ */

/**
 * Show swipe hint animation
 */
function showSwipeHint() {
    if (!elements.swipeHint || state.swipeHintShown) return;
    
    elements.swipeHint.classList.remove('show');
    // Force reflow to restart animation
    void elements.swipeHint.offsetWidth;
    elements.swipeHint.classList.add('show');
}

/**
 * Hide swipe hint permanently
 */
function hideSwipeHint() {
    state.swipeHintShown = true;
    
    if (elements.swipeHint) {
        elements.swipeHint.classList.remove('show');
        elements.swipeHint.style.display = 'none';
    }
}

/**
 * Initialize swipe hint for mobile
 */
function initializeSwipeHint() {
    if (!state.isMobile || !elements.swipeHint) return;
    
    // Show hint after initial delay
    setTimeout(() => {
        showSwipeHint();
        
        // Repeat hint periodically until user swipes
        const hintInterval = setInterval(() => {
            if (!state.swipeHintShown) {
                showSwipeHint();
            } else {
                clearInterval(hintInterval);
            }
        }, CONFIG.HINT_REPEAT_INTERVAL);
    }, CONFIG.HINT_INITIAL_DELAY);
    
    // Wrap rotateCards to hide hint on first swipe
    const originalRotateCards = rotateCards;
    window.rotateCards = function() {
        if (!state.swipeHintShown) {
            hideSwipeHint();
        }
        originalRotateCards.call(this);
    };
}

/* ============================================
   EVENT LISTENERS
   ============================================ */

function attachEventListeners() {
    // Mouse interactions
    elements.deckContainer.addEventListener('mousemove', handleMouseMove);
    elements.deckContainer.addEventListener('mouseleave', handleMouseLeave);
    
    // Scroll
    window.addEventListener('wheel', handleWheel);
    
    // Touch
    window.addEventListener('touchstart', handleTouchStart);
    window.addEventListener('touchend', handleTouchEnd);
    
    // Theme switcher buttons
    document.addEventListener('click', (e) => {
        if (e.target.closest('.theme-btn')) {
            const btn = e.target.closest('.theme-btn');
            const theme = btn.dataset.theme;
            const card = btn.closest('.card');
            
            if (card) {
                // Save current transform if card is active
                const currentTransform = card.dataset.pos === '0' ? card.style.transform : '';
                
                // Remove all theme classes
                card.classList.remove('theme-dark', 'theme-ice', 'theme-fire', 'theme-electric', 'theme-psychic', 'theme-grass');
                // Add new theme
                card.classList.add(`theme-${theme}`);
                
                // Update background if it's the active card
                if (card.dataset.pos === '0') {
                    // Update background color only
                    const activeCard = elements.cards[0];
                    let themeColor = CONFIG.THEME_COLORS.default;
                    
                    if (activeCard.classList.contains('theme-dark')) {
                        themeColor = CONFIG.THEME_COLORS.dark;
                    } else if (activeCard.classList.contains('theme-fire')) {
                        themeColor = CONFIG.THEME_COLORS.fire;
                    } else if (activeCard.classList.contains('theme-electric')) {
                        themeColor = CONFIG.THEME_COLORS.electric;
                    } else if (activeCard.classList.contains('theme-psychic')) {
                        themeColor = CONFIG.THEME_COLORS.psychic;
                    } else if (activeCard.classList.contains('theme-grass')) {
                        themeColor = CONFIG.THEME_COLORS.grass;
                    } else if (activeCard.classList.contains('theme-ice')) {
                        themeColor = CONFIG.THEME_COLORS.ice;
                    }
                    
                    elements.body.style.backgroundColor = themeColor;
                    
                    // Update Swirl background theme (desktop only)
                    if (state.swirlBackground && !state.isMobile) {
                        state.swirlBackground.setTheme(theme);
                    }
                    
                    // Restore transform
                    if (currentTransform) {
                        card.style.transform = currentTransform;
                    }
                }
            }
        }
    });
}

/* ============================================
   INITIALIZATION
   ============================================ */

function init() {
    // Update dynamic fields (age, experience)
    updateDynamicFields();
    
    // Update images from config
    updateImages();
    
    // Update social links from config
    updateSocialLinks();
    
    // Set initial card positions and background
    updatePositions();
    
    // Initialize Swirl background (desktop only)
    if (!state.isMobile && window.SwirlBackground) {
        state.swirlBackground = new SwirlBackground('canvas-background');
        
        // Set initial theme based on first card
        const activeCard = elements.cards[0];
        let initialTheme = 'default';
        
        if (activeCard.classList.contains('theme-dark')) {
            initialTheme = 'dark';
        } else if (activeCard.classList.contains('theme-fire')) {
            initialTheme = 'fire';
        } else if (activeCard.classList.contains('theme-electric')) {
            initialTheme = 'electric';
        } else if (activeCard.classList.contains('theme-psychic')) {
            initialTheme = 'psychic';
        } else if (activeCard.classList.contains('theme-grass')) {
            initialTheme = 'grass';
        } else if (activeCard.classList.contains('theme-ice')) {
            initialTheme = 'ice';
        }
        
        state.swirlBackground.setTheme(initialTheme);
    }
    
    // Attach event listeners
    attachEventListeners();
    
    // Initialize mobile-specific features
    if (state.isMobile) {
        initializeGyroscope();
        initializeSwipeHint();
    }
}

// Start the application
init();
